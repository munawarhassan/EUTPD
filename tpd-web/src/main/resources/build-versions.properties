# use semantic version [version]-[state].[buildnumber]
revision.version=
# use maven plugin pl.project13.maven::git-commit-id-plugin
# git branch
scm.branch=${git.branch}
# git.dirty
scm.dirty=${git.dirty}
# {git.tags}
scm.tags=${git.tags}
# {git.build.user.name}
scm.build.user.name=${git.build.user.name}
# {git.build.user.email}
scm.build.user.email=${git.build.user.email}
# {git.build.time}. format used 'dd.MM.yyyy'@'HH:mm:ss z'
scm.build.time=${git.build.time}

# ${git.commit.id}
scm.commit.id=${git.commit.id}

scm.commit.id.abbrev=${git.commit.id.abbrev}
# {git.local.branch.ahead}
scm.local.branch.ahead=${git.local.branch.ahead}
# {git.total.commit.count}
scm.total.commit.count=${git.total.commit.count}
# {git.closest.tag.commit.count}
scm.closest.tag.commit.count=${git.closest.tag.commit.count}
# {git.local.branch.behind}
scm.local.branch.behind=${git.local.branch.behind}
# application version
scm.commit.version=${git.build.version}-${git.closest.tag.commit.count}-${git.commit.id.abbrev}-${git.branch}
# {git.build.version}
scm.build.version=${git.build.version}
# {git.commit.id.describe-short}
scm.commit.short-version=${git.commit.id.describe-short}
# {git.commit.user.name}
scm.commit.user.name=${git.commit.user.name}
# {git.commit.user.email}
scm.commit.user.email=${git.commit.user.email}
# {git.commit.message.full}
scm.commit.message.full=${git.commit.message.full}
# {git.commit.message.short}
scm.commit.message.short=${git.commit.message.short}
# {git.commit.time}. format used 'dd.MM.yyyy'@'HH:mm:ss z'
scm.commit.time=${git.commit.time}
# The git.build.number variables are available on some hosted CIs and can be used to identify the "number" of the build.
scm.build.number=${git.build.number}
# holds a system wide unique build number
scm.build.number.unique=${git.build.number.unique}
